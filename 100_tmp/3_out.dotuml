ClassDiagram {


class usb_request {
	"void" : "    *buf"
	"unsigned" : "length"
	"dma_addr_t" : "      dma"
	"unsigned" : "stream_id:16"
	"unsigned" : "no_interrupt:1"
	"unsigned" : "zero:1"
	"unsigned" : "short_not_ok:1"
	"void            (*complete)"(usb_ep:"*ep" , usb_request:"*req")
	"void" : "    *context"
	"struct list_head" : "list"
	"int" : "     status"
	"unsigned" : "actual"
	"unsigned int" : "    frame_number"
    "//  0 "(musb_request)
}

class uvc_request_data {
	"signed int" : "      length"
	"__u8" : "    data[60]"
}

class usb_ep_ops {
	"int (*enable) (struct usb_ep *ep,struct usb_endpoint_descriptor" : " *desc)"
	"int (*disable) (struct usb_ep" : "*ep)"
	"struct usb_request *(*alloc_request) (struct usb_ep *ep,gfp_t" : " gfp_flags)"
	"void (*free_request) (struct usb_ep *ep, struct usb_request" : " *req)"
	"int (*queue) (struct usb_ep *ep, struct usb_request *req,gfp_t" : " gfp_flags)"
	"int (*dequeue) (struct usb_ep *ep, struct usb_request" : " *req)"
	"int (*set_halt) (struct usb_ep *ep, int" : " value)"
	"int (*set_wedge)"(usb_ep:"*ep")
	"int (*fifo_status) (struct usb_ep" : "*ep)"
	"void (*fifo_flush) (struct usb_ep" : "*ep)"
    "//  0 "(usb_ep)
}

class usb_ep_caps {
	"unsigned" : "type_control:1"
	"unsigned" : "type_iso:1"
	"unsigned" : "type_bulk:1"
	"unsigned" : "type_int:1"
	"unsigned" : "dir_in:1"
	"unsigned" : "dir_out:1"
    "//  1 "(usb_ep)
}

class usb_ep {
	"void" : "    *driver_data"
	"char" : "      *name"
	"struct usb_ep_ops" : " *ops  /*0*/"
	"struct list_head" : "ep_list"
	"struct usb_ep_caps" : "      caps  /*1*/"
	"bool" : "    claimed"
	"bool" : "    enabled"
	"unsigned" : "maxpacket:16"
	"unsigned" : "maxpacket_limit:16"
	"unsigned" : "max_streams:16"
	"unsigned" : "mult:2"
	"unsigned" : "maxburst:5"
	"u8" : "      address"
	"struct usb_endpoint_descriptor" : " *desc"
	"struct usb_ss_ep_comp_descriptor" : " *comp_desc"
    "//  1 "(usb_gadget)
    "//  0 "(musb_ep)
}

class usb_dcd_config_params {
	"__u8" : "    bU1devExitLat"
	"__le16" : "  bU2DevExitLat"
}

class usb_gadget_ops {
	"int (*get_frame)"(usb_gadget:"*")
	"int (*wakeup)"(usb_gadget:"*")
	"int (*set_selfpowered) (struct usb_gadget *, int" : " is_selfpowered)"
	"int (*vbus_session) (struct usb_gadget *, int" : " is_active)"
	"int (*vbus_draw) (struct usb_gadget *, unsigned" : " mA)"
	"int (*pullup) (struct usb_gadget *, int" : " is_on)"
	"int (*ioctl)"(usb_gadget:"*" , unsigned:"code" , long:"param")
	"void    (*get_config_params)"(usb_dcd_config_params:"*")
	"int (*udc_start)"(usb_gadget:"*" , usb_gadget_driver:"*")
	"int (*udc_stop)"(usb_gadget:"*")
	"void    (*udc_set_speed)"(usb_gadget:"*" , enum:"usb_device_speed")
	"struct usb_ep *(*match_ep)"(usb_gadget:"*" , usb_endpoint_descriptor:"*" , usb_ss_ep_comp_descriptor:"*")
    "//  0 "(usb_gadget)
}

class usb_gadget {
	"struct usb_udc" : "  *udc"
	"struct usb_gadget_ops" : "*ops  /*0*/"
	"struct usb_ep" : "   *ep0  /*1*/"
	"struct list_head" : "ep_list"
	"enum usb_device_speed" : "   speed"
	"enum usb_device_speed" : "   max_speed"
	"enum usb_device_state" : "   state"
	"char" : "      *name"
	"int" : "     dev"
	"void *" : "  private_data"
	"unsigned" : "out_epnum"
	"unsigned" : "in_epnum"
	"unsigned" : "mA"
	"unsigned" : "isoch_delay"
	"unsigned" : "sg_supported:1"
	"unsigned" : "is_otg:1"
	"unsigned" : "is_a_peripheral:1"
	"unsigned" : "b_hnp_enable:1"
	"unsigned" : "a_hnp_support:1"
	"unsigned" : "a_alt_hnp_support:1"
	"unsigned" : "hnp_polling_support:1"
	"unsigned" : "host_request_flag:1"
	"unsigned" : "quirk_ep_out_aligned_size:1"
	"unsigned" : "quirk_altset_not_supp:1"
	"unsigned" : "quirk_stall_not_supp:1"
	"unsigned" : "quirk_zlp_not_supp:1"
	"unsigned" : "quirk_avoids_skb_reserve:1"
	"unsigned" : "is_selfpowered:1"
	"unsigned" : "deactivated:1"
	"unsigned" : "connected:1"
	"unsigned" : "lpm_capable:1"
    "//  4 "(musb)
}

class usb_gadget_driver {
	"char" : "    *function"
	"enum usb_device_speed" : "   max_speed"
	"int         (*bind)"(usb_gadget:"*gadget" , usb_gadget_driver:"*driver")
	"void            (*unbind)"(usb_gadget:"*")
	"int         (*setup)"(usb_gadget:"*" , usb_ctrlrequest:"*")
	"void            (*disconnect)"(usb_gadget:"*")
	"void            (*suspend)"(usb_gadget:"*")
	"void            (*resume)"(usb_gadget:"*")
	"void            (*reset)"(usb_gadget:"*")
	"char" : "    *udc_name"
	"struct list_head" : "pending"
	"unsigned" : "match_existing_only:1"
    "//  5 "(musb)
}

class usb_string {
	"u8" : "      id"
	"char" : "      *s"
    "//  0 "(usb_gadget_strings)
}

class usb_gadget_strings {
	"u16" : "     language"
	"struct usb_string" : "       *strings  /*0*/"
}

class usb_gadget_string_container {
	"struct list_head" : "list"
	"u8" : "      *stash[0]"
}

class musb_fifo_cfg {
	"u8" : "      hw_ep_num"
	"enum musb_fifo_style" : "    style"
	"enum musb_buf_mode" : "      mode"
	"u16" : "     maxpacket"
    "//  0 "(musb_hdrc_config)
}

class musb_hdrc_eps_bits {
	"char" : "      name[16]"
	"u8" : "      bits"
    "//  1 "(musb_hdrc_config)
}

class musb_hdrc_config {
	"struct musb_fifo_cfg" : "    *fifo_cfg  /*0*/"
	"unsigned" : "fifo_cfg_size"
	"unsigned" : "multipoint:1"
	"unsigned" : "dyn_fifo:1"
	"unsigned" : "soft_con:1"
	"unsigned" : "utm_16:1"
	"unsigned" : "big_endian:1"
	"unsigned" : "mult_bulk_tx:1"
	"unsigned" : "mult_bulk_rx:1"
	"unsigned" : "high_iso_tx:1"
	"unsigned" : "high_iso_rx:1"
	"unsigned" : "dma:1"
	"unsigned" : "vendor_req:1"
	"u8" : "      num_eps"
	"u8" : "      dma_channels"
	"u8" : "      dyn_fifo_size"
	"u8" : "      vendor_ctrl"
	"u8" : "      vendor_stat"
	"u8" : "      dma_req_chan"
	"u8" : "      ram_bits"
	"struct musb_hdrc_eps_bits" : "*eps_bits  /*1*/"
    "//  0 "(musb_hdrc_platform_data)
    "//  6 "(musb)
}

class musb_hdrc_platform_data {
	"u8" : "      mode"
	"char" : "      *clock"
	"int     (*set_vbus)"(device:"*dev" , int:"is_on")
	"u8" : "      min_power"
	"int     (*set_power)"(int:"state")
	"struct musb_hdrc_config" : " *config  /*0*/"
	"void" : "    *board_data"
	"void" : "      *platform_ops"
}

class musb_platform_ops {
	"int (*init)"(musb:"*musb")
	"int (*exit)"(musb:"*musb")
	"int (*enable)"(musb:"*musb")
	"void    (*disable)"(musb:"*musb")
	"int (*set_mode)"(musb:"*musb" , u8:"mode")
	"int (*vbus_status)"(musb:"*musb")
	"void    (*set_vbus)"(musb:"*musb" , int:"on")
	"int (*adjust_channel_params)"(int:"a")
	"void    (*pre_root_reset_end)"(musb:"*musb")
	"void    (*post_root_reset_end)"(musb:"*musb")
    "//  0 "(musb)
}

class musb_hw_ep {
	"struct musb" : "     *musb  /*0*/"
	"void __iomem" : "    *fifo"
	"void __iomem" : "    *regs"
	"u8" : "      epnum"
	"bool" : "    is_shared_fifo"
	"bool" : "    tx_double_buffered"
	"bool" : "    rx_double_buffered"
	"u16" : "     max_packet_sz_tx"
	"u16" : "     max_packet_sz_rx"
	"struct dma_channel" : "      *tx_channel"
	"struct dma_channel" : "      *rx_channel"
	"void __iomem" : "    *target_regs"
	"u8" : "      rx_reinit"
	"u8" : "      tx_reinit"
	"struct musb_ep" : "  ep_in  /*1*/"
	"struct musb_ep" : "  ep_out  /*2*/"
    "//  2 "(musb)
    "//  3 "(musb)
    "//  1 "(musb_ep)
}

class musb_csr_regs {
	"u16 txmaxp, txcsr, rxmaxp," : "rxcsr"
	"u16 rxfifoadd," : "  txfifoadd"
	"u8 txtype, txinterval, rxtype," : " rxinterval"
	"u8 rxfifosz," : "    txfifosz"
	"u8 txfunaddr, txhubaddr," : "txhubport"
	"u8 rxfunaddr, rxhubaddr," : "rxhubport"
    "//  0 "(musb_context_registers)
}

class musb_context_registers {
	"u8" : "      power"
	"u16 intrtxe," : "    intrrxe"
	"u8" : "      intrusbe"
	"u16" : "     frame"
	"u8 index," : "       testmode"
	"u8 devctl, busctl," : "      misc"
	"u32" : "     otg_interfsel"
	"struct musb_csr_regs" : " index_regs[MUSB_C_NUM_EPS]  /*0*/"
    "//  1 "(musb)
}

class musb {
	"spinlock_t" : "      lock"
	"struct musb_io" : "  io"
	"struct musb_platform_ops" : "*ops  /*0*/"
	"struct musb_context_registers" : "context  /*1*/"
	"irqreturn_t     (*isr)"(in:"int" , void:"*")
	"u16" : "     hwvers"
	"u32" : "     port1_status"
	"unsigned long" : "   rh_timer"
	"enum musb_h_ep0_state" : "   ep0_stage"
	"struct musb_hw_ep" : "       *bulk_ep  /*2*/"
	"struct list_head" : "control"
	"struct list_head" : "in_bulk"
	"struct list_head" : "out_bulk"
	"struct dma_controller" : "   *dma_controller"
	"struct device" : "   *controller"
	"void __iomem" : "    *ctrl_base"
	"void __iomem" : "    *mregs"
	"u8" : "      int_usb"
	"u16" : "     int_rx"
	"u16" : "     int_tx"
	"unsigned char" : "   state"
	"int" : "     nIrq"
	"unsigned" : "irq_wake:1"
	"struct musb_hw_ep" : " endpoints[MUSB_C_NUM_EPS]  /*3*/"
	"u16" : "     vbuserr_retry"
	"u16" : "     epmask"
	"u8" : "      nr_endpoints"
	"u8" : "      board_mode"
	"int         (*board_set_power)"(int:"state")
	"u8" : "      min_power"
	"bool" : "    is_host"
	"int" : "     a_wait_bcon"
	"unsigned long" : "   idle_timeout"
	"unsigned" : "is_active:1"
	"unsigned" : "is_multipoint:1"
	"unsigned" : "ignore_disconnect:1"
	"unsigned" : "hb_iso_rx:1"
	"unsigned" : "hb_iso_tx:1"
	"unsigned" : "dyn_fifo:1"
	"unsigned" : "bulk_split:1"
	"unsigned" : "is_suspended:1"
	"unsigned" : "may_wakeup:1"
	"unsigned" : "is_self_powered:1"
	"unsigned" : "is_bus_powered:1"
	"unsigned" : "set_address:1"
	"unsigned" : "test_mode:1"
	"unsigned" : "softconnect:1"
	"u8" : "      address"
	"u8" : "      test_mode_nr"
	"u16" : "     ackpend"
	"enum musb_g_ep0_state" : "   ep0_state"
	"struct usb_gadget" : "       g  /*4*/"
	"struct usb_gadget_driver" : "*gadget_driver  /*5*/"
	"unsigned" : "double_buffer_not_ok:1"
	"struct musb_hdrc_config" : " *config  /*6*/"
    "//  0 "(musb_hw_ep)
    "//  2 "(musb_request)
    "//  2 "(musb_ep)
}

class musb_request {
	"struct usb_request" : "      request  /*0*/"
	"struct list_head" : "list"
	"struct musb_ep" : "  *ep  /*1*/"
	"struct musb" : "     *musb  /*2*/"
	"u8" : "      tx"
	"u8" : "      epnum"
	"enum buffer_map_state" : "   map_state"
}

class musb_ep {
	"struct usb_ep" : "   end_point  /*0*/"
	"char" : "    name[12]"
	"struct musb_hw_ep" : "       *hw_ep  /*1*/"
	"struct musb" : "     *musb  /*2*/"
	"u8" : "      current_epnum"
	"u8" : "      type"
	"u8" : "      is_in"
	"u16" : "     packet_sz"
	"struct usb_endpoint_descriptor" : " *desc"
	"struct dma_channel" : "      *dma"
	"struct list_head" : "req_list"
	"u8" : "      wedged"
	"u8" : "      busy"
	"u8" : "      hb_mult"
    "//  1 "(musb_hw_ep)
    "//  2 "(musb_hw_ep)
    "//  1 "(musb_request)
}




usb_request -c-> musb_request
usb_ep_caps -c-> usb_ep
usb_ep -c-> musb_ep
usb_gadget -c-> musb
musb_hw_ep -c-> musb
musb_csr_regs -c-> musb_context_registers
musb_context_registers -c-> musb
musb_ep -c-> musb_hw_ep
usb_ep_ops -a-> usb_ep
usb_ep -a-> usb_gadget
usb_gadget_ops -a-> usb_gadget
usb_gadget_driver -a-> musb
usb_string -a-> usb_gadget_strings
musb_fifo_cfg -a-> musb_hdrc_config
musb_hdrc_eps_bits -a-> musb_hdrc_config
musb_hdrc_config -a-> musb_hdrc_platform_data
musb_hdrc_config -a-> musb
musb_platform_ops -a-> musb
musb_hw_ep -a-> musb
musb_hw_ep -a-> musb_ep
musb -a-> musb_hw_ep
musb -a-> musb_request
musb -a-> musb_ep
musb_ep -a-> musb_request

}