/***************************************************************************
  Copyright (c) 2019 Huajie IMI Technology Co., Ltd.
  All rights reserved.

  @brief    mipi driver
  @author   Dejie Zhang

  @History
  When         Who           What, where, why
  ----------   -----------   ----------------------------------------------
  2019/03/21   Dejie Zhang   the initial version

===========================================================================
***************************************************************************/

#if defined(CHIP_IMI_1680)
#include "vic_int.h"
#include "csi_rx.h"
#include "delay.h"
#include "imi_io.h"
#include "csi_rx.h"
#include "imi_type.h"
#include "elog.h"
#include "i2c.h"
#include "string.h"
#include "clock.h"

//#define MIPI_CSI_BASE		0x23200000
//#define MIPI_RX_BUS_BASE	0x23f00800
#define MIPI_CSI_BASE		0x24200000
#define MIPI_RX_BUS_BASE	0x24f00800
#define CAMIF_OUT_ADDR		0xA0000000
#define TOP_OFFSET			0x800
#define CAMIF_OFFSET		0xC00
#define DPHY_OFFSET 		0x1000

IMI_MIPI_T g_mpcfg = NULL;

#if (SYNPSYS_DPHY_TESTCHIP == 1)

#define GLUELOGIC_TESTER 	0x4
#define TX_PHY_TESTER		0x1
#define RX_PHY_TESTER		0x2

static unsigned int hsfreqrange     = 0;
static unsigned int osc_freq        = 0;
static unsigned int cfgclkfreqrange = 0;
static const struct {
	unsigned int max_mbps;
	unsigned int hsfreqrange;
	unsigned int osc_freq;
} hsfreq_map[] = {
	{80, 0x00, 438},   {90, 0x10, 438},   {100, 0x20, 438},
	{110, 0x30, 438},  {120, 0x01, 438},  {130, 0x11, 438},
	{140, 0x21, 438},  {150, 0x31, 438},  {160, 0x02, 438},
	{170, 0x12, 438},  {180, 0x22, 438},  {190, 0x32, 438},
	{205, 0x03, 438},  {220, 0x13, 438},  {235, 0x23, 438},
	{250, 0x33, 438},  {275, 0x04, 438},  {300, 0x14, 438},
	{325, 0x25, 438},  {350, 0x35, 438},  {400, 0x05, 438},
	{450, 0x16, 438},  {500, 0x26, 438},  {550, 0x37, 438},
	{600, 0x07, 438},  {650, 0x18, 438},  {700, 0x28, 438},
	{750, 0x39, 438},  {800, 0x09, 438},  {850, 0x19, 438},
	{900, 0x29, 438},  {950, 0x3a, 438},  {1000, 0x0a, 438},
	{1050, 0x1a, 438}, {1100, 0x2a, 438}, {1150, 0x3b, 438},
	{1200, 0x0b, 438}, {1250, 0x1b, 438}, {1300, 0x2b, 438},
	{1350, 0x3c, 438}, {1400, 0x0c, 438}, {1450, 0x1c, 438},
	{1500, 0x2c, 438}, {1550, 0x3d, 271}, {1600, 0x0d, 280},
	{1650, 0x1d, 289}, {1700, 0x2d, 298}, {1750, 0x3e, 306},
	{1800, 0x0e, 315}, {1850, 0x1e, 324}, {1900, 0x2e, 333},
	{1950, 0x3f, 341}, {2000, 0x0f, 350}, {2050, 0x40, 359},
	{2100, 0x41, 368}, {2150, 0x42, 376}, {2200, 0x43, 385},
	{2250, 0x44, 394}, {2300, 0x45, 403}, {2350, 0x46, 411},
	{2400, 0x47, 420}, {2450, 0x48, 428}, {2500, 0x49, 438},
};

static int mbps_to_index(unsigned int mbps)
{
	int i;

	for (i = 0; i < ARRAY_SIZE(hsfreq_map); i++) {
		if (hsfreq_map[i].max_mbps >= mbps)
			return i;
	}

	if (i >= ARRAY_SIZE(hsfreq_map))
		i = ARRAY_SIZE(hsfreq_map) - 1;

	return i;
}

static void imi_csi_calc_freq(unsigned int mbps)
{
	int index;
	index = mbps_to_index(mbps);
	hsfreqrange = hsfreq_map[index].hsfreqrange;
	osc_freq = hsfreq_map[index].osc_freq;
	log_d("freq index:%d\n", index);
}
#endif

void mipi_irq_enable(void)
{
	__asm volatile (
		"STMDB	SP!, {R0}			\n\t"	/* Push R0.						*/
		"MRS	R0, CPSR			\n\t"	/* Get CPSR.					*/
		"BIC	R0, R0, #0xC0		\n\t"	/* Enable IRQ, FIQ.				*/
		"MSR	CPSR, R0			\n\t"	/* Write back modified value.	*/
		"LDMIA	SP!, {R0}" );				/* Pop R0.	*/
}

void mipi_irq_disable(void)
{
	__asm volatile (
		"STMDB	SP!, {R0}			\n\t"	/* Push R0.						*/
		"MRS	R0, CPSR			\n\t"	/* Get CPSR.					*/
		"ORR	R0, R0, #0xC0		\n\t"	/* Disable IRQ, FIQ.			*/
		"MSR	CPSR, R0			\n\t"	/* Write back modified value.	*/
		"LDMIA	SP!, {R0}" );				/* Pop R0.						*/
}

/***********************************************************************
 *
 * CAMIF Module
 *
 ***********************************************************************/


/***********************************************************************
 *
 * MIPI CTL Module
 *
 ***********************************************************************/
static inline void csi2_write_reg(unsigned int reg, unsigned int val)
{
	writel(val, g_mpcfg->mod_base + reg);
}

static inline unsigned int csi2_read_reg(unsigned int reg)
{
	return readl(g_mpcfg->mod_base + reg);
}

static void mipi_ctl_init(IMI_MIPI_T mipi_cfg)
{
	imi_printf("Enter %s\n", __func__);
	csi2_write_reg(MIPI_CSI2_RESET,			0x1);
	csi2_write_reg(MIPI_IPI_MODE,			IPI_16BIT_MODE | CAMERA_TIMING);
	switch (mipi_cfg->vcno) {
	case 3:
		csi2_write_reg(MIPI_IPI2_VCID,			0x2);
		csi2_write_reg(MIPI_IPI1_VCID,			0x1);
		csi2_write_reg(MIPI_IPI0_VCID,			0x0);
		break;
	case 2:
		csi2_write_reg(MIPI_IPI2_VCID,			0x3);
		csi2_write_reg(MIPI_IPI1_VCID,			0x1);
		csi2_write_reg(MIPI_IPI0_VCID,			0x0);
		break;
	case 1:
		csi2_write_reg(MIPI_IPI2_VCID,			0x3);
		csi2_write_reg(MIPI_IPI1_VCID,			0x3);
		csi2_write_reg(MIPI_IPI0_VCID,			0x0);
		break;
	}

	csi2_write_reg(MIPI_IPI_DATA_TYPE,		mipi_cfg->data_t);
	csi2_write_reg(MIPI_IPI_HSA_TIME,		0x1f);
	csi2_write_reg(MIPI_IPI_HBP_TIME,		0x1f);
	csi2_write_reg(MIPI_IPI_HSD_TIME,		0x0a);
	csi2_write_reg(MIPI_IPI_HLINE_TIME,		0x650);
	csi2_write_reg(MIPI_IPI_VSA_LINES,		0x02);
	csi2_write_reg(MIPI_IPI_VBP_LINES,		0x02);
	csi2_write_reg(MIPI_IPI_VFP_LINES,		0x0f);
	csi2_write_reg(MIPI_IPI_VACTIVE_LINES,	0x78);
	csi2_write_reg(MIPI_N_LANES,			mipi_cfg->lanes - 1);
	//mipi_irq_enable();
	imi_printf("Exit %s\n", __func__);
}



/***********************************************************************
 *
 * MIPI TOP Module
 *
 ***********************************************************************/
static inline void top_write_reg(unsigned int reg, unsigned int val)
{
	writel(val, g_mpcfg->mod_base + TOP_OFFSET + reg);
}

static inline unsigned int top_read_reg(unsigned int reg)
{
	return readl(g_mpcfg->mod_base + TOP_OFFSET + reg);
}

#if (SYNPSYS_DPHY_TESTCHIP == 1)
static void top_choose_tester(unsigned int mode)
{
	unsigned int reg_val;
	reg_val = top_read_reg(TOP_DPHY_CTRL);
	reg_val = (reg_val & 0x000fffff) | (mode << 21);
	top_write_reg(TOP_DPHY_CTRL, reg_val);
	log_d("[TOP]TOP_DPHY_CTRL value:0x%08x\n", top_read_reg(TOP_DPHY_CTRL));
}
#endif

static void top_conf_init(IMI_MIPI_T mipi_cfg)
{
	unsigned int dwidth = mipi_cfg->data_t - MIPI_RAW_8BIT;

	imi_printf("Enter %s\n", __func__);
	switch(mipi_cfg->vcno) {
	case 3:
		top_write_reg(TOP_IPI2_CTRL, 
			IPI_ENABLE | (dwidth<<1) | IPI_HIGH_16BIT | (1<<7));
		top_write_reg(TOP_IPI2_FRAMESIZE, 
			(mipi_cfg->width << 16) | mipi_cfg->height);
		top_write_reg(TOP_IPI2_VSYNCDELAY, (0x10<<16) | 0x10);
	case 2:
		top_write_reg(TOP_IPI1_CTRL, 
			IPI_ENABLE | (dwidth<<1) | IPI_HIGH_16BIT | (1<<7));
		top_write_reg(TOP_IPI1_FRAMESIZE, 
			(mipi_cfg->width << 16) | mipi_cfg->height);
		top_write_reg(TOP_IPI1_VSYNCDELAY, (0x10<<16) | 0x10);
	case 1:
		top_write_reg(TOP_IPI0_CTRL, 
			IPI_ENABLE | (dwidth<<1) | IPI_HIGH_16BIT | (1<<7));
		top_write_reg(TOP_IPI0_FRAMESIZE, 
			(mipi_cfg->width << 16) | mipi_cfg->height);
		top_write_reg(TOP_IPI0_VSYNCDELAY, (0x10<<16) | 0x10);
	}
	imi_printf("Exit %s\n", __func__);

}

static void top_enable_mipi(void)
{
	unsigned int reg_val;

	imi_printf("Enter %s\n", __func__);
	reg_val = top_read_reg(TOP_DPHY_CTRL);
#if (SYNPSYS_DPHY_TESTCHIP == 1)
	top_write_reg(TOP_DPHY_CTRL, reg_val | PHY_CLK_ENABLE | 
		PHY_DIR_RX | (cfgclkfreqrange << 2) | (hsfreqrange << 10));
#else
	top_write_reg(TOP_DPHY_CTRL, reg_val | PHY_CLK_ENABLE | PHY_DIR_RX);
#endif
	top_write_reg(TOP_PHY_LAN0ESC_CTRL, 0);

	log_d("[EN]TOP_DPHY_CTRL value:0x%08x\n", top_read_reg(TOP_DPHY_CTRL));
	imi_printf("Exit %s\n", __func__);
}



/***********************************************************************
 *
 * MIPI DPHY Module
 *
 ***********************************************************************/
#if (VERISLC_DPHY_TESTCHIP == 1)
struct dw_i2c_dev *mipi_i2c_dev;
struct i2c_client mipi_i2c_slave =
	/* {0x27, I2C_ADDR_M_7BIT, I2C_SIZE_8BIT, I2C_SIZE_8BIT, 0};// rx addr */
	{0x28, I2C_ADDR_M_7BIT, I2C_SIZE_8BIT, I2C_SIZE_8BIT, 0};// chip addr


static int mipi_dphy_write(u32 reg, u32 val)
{
	int ret = 0;
	ret = i2c_write(mipi_i2c_dev, &mipi_i2c_slave, reg, val);
	return ret;
}

static int mipi_dphy_read(u32 reg, u32 *ret_val)
{

	return i2c_read(mipi_i2c_dev, &mipi_i2c_slave, reg, ret_val);
}

#elif (SYNPSYS_DPHY_TESTCHIP == 1)
static void mipi_dphy_write(u32 code, u32 data)
{
	u8 code_msb = (code >> 8) & 0xf;
	u8 code_lsb = code & 0xff;

	/* write 4-bit MSB testcode */
	csi2_write_reg(MIPI_PHY_TEST_CTRL1, DPHY_TESTEN);
	csi2_write_reg(MIPI_PHY_TEST_CTRL0, DPHY_TESTCLK);
	csi2_write_reg(MIPI_PHY_TEST_CTRL1, DPHY_TESTEN | 0x00);
	/* failing edge on testclk, testdin signal context is latched internally*/
	csi2_write_reg(MIPI_PHY_TEST_CTRL0, 0);
	csi2_write_reg(MIPI_PHY_TEST_CTRL1, 0);
	csi2_write_reg(MIPI_PHY_TEST_CTRL1, code_msb);
	csi2_write_reg(MIPI_PHY_TEST_CTRL0, DPHY_TESTCLK);

	/* write 8-bit LSB testcode */
	csi2_write_reg(MIPI_PHY_TEST_CTRL0, 0);
	csi2_write_reg(MIPI_PHY_TEST_CTRL1, DPHY_TESTEN);
	csi2_write_reg(MIPI_PHY_TEST_CTRL0, DPHY_TESTCLK);
	csi2_write_reg(MIPI_PHY_TEST_CTRL1, DPHY_TESTEN | code_lsb);
	/* failing edge on testclk, testdin signal context is latched internally*/
	csi2_write_reg(MIPI_PHY_TEST_CTRL0, 0);
	csi2_write_reg(MIPI_PHY_TEST_CTRL1, 0);

	/* write 8-bit testdata */
	csi2_write_reg(MIPI_PHY_TEST_CTRL1, data);
	csi2_write_reg(MIPI_PHY_TEST_CTRL0, DPHY_TESTCLK);
}

static int mipi_dphy_read(unsigned int code)
{
	int val;
	u8 code_msb = (code >> 8) & 0xf;
	u8 code_lsb = code & 0xff;

	/* write 4-bit MSB testcode */
	csi2_write_reg(MIPI_PHY_TEST_CTRL1, DPHY_TESTEN);
	csi2_write_reg(MIPI_PHY_TEST_CTRL0, DPHY_TESTCLK);
	csi2_write_reg(MIPI_PHY_TEST_CTRL1, DPHY_TESTEN | 0x00);
	/* failing edge on testclk, testdin signal context is latched internally*/
	csi2_write_reg(MIPI_PHY_TEST_CTRL0, 0);
	csi2_write_reg(MIPI_PHY_TEST_CTRL1, 0);
	csi2_write_reg(MIPI_PHY_TEST_CTRL1, code_msb);
	csi2_write_reg(MIPI_PHY_TEST_CTRL0, DPHY_TESTCLK);

	/* write 8-bit LSB testcode */
	csi2_write_reg(MIPI_PHY_TEST_CTRL0, 0);
	csi2_write_reg(MIPI_PHY_TEST_CTRL1, DPHY_TESTEN);
	csi2_write_reg(MIPI_PHY_TEST_CTRL0, DPHY_TESTCLK);
	csi2_write_reg(MIPI_PHY_TEST_CTRL1, DPHY_TESTEN | code_lsb);
	/* failing edge on testclk, testdin signal context is latched internally*/
	csi2_write_reg(MIPI_PHY_TEST_CTRL0, 0);
	csi2_write_reg(MIPI_PHY_TEST_CTRL1, 0);

	/* read 8-bit testdata */
	val = csi2_read_reg(MIPI_PHY_TEST_CTRL1);
	val = (val >> 8) & 0xff;

	return val;
}

static void mipi_dphy_osc_freq(void)
{
	/*write osc_freq_target*/
	mipi_dphy_write(0xe2, osc_freq & 0xff);
	mipi_dphy_write(0xe3, (osc_freq >> 8) & 0xff);
	mipi_dphy_write(0xe4, 0x1);
	mipi_dphy_write(0x08, 0x38);

	log_d("dphy read 0xe2 reg:0x%08x\n", mipi_dphy_read(0xe2));
	log_d("dphy read 0xe3 reg:0x%08x\n", mipi_dphy_read(0xe3));
	log_d("dphy read 0x08 reg:0x%08x\n", mipi_dphy_read(0x08));
}

static void clear_reg_bank(void)
{
	top_choose_tester(GLUELOGIC_TESTER);
	csi2_write_reg(MIPI_PHY_TEST_CTRL0, DPHY_TESTCLR);	// 0x50
	udelay(2);
	csi2_write_reg(MIPI_PHY_TEST_CTRL0, 0);

	top_choose_tester(TX_PHY_TESTER);
	csi2_write_reg(MIPI_PHY_TEST_CTRL0, DPHY_TESTCLR);
	udelay(2);
	csi2_write_reg(MIPI_PHY_TEST_CTRL0, 0);
	top_choose_tester(RX_PHY_TESTER);
	csi2_write_reg(MIPI_PHY_TEST_CTRL0, DPHY_TESTCLR);
	udelay(2);
	csi2_write_reg(MIPI_PHY_TEST_CTRL0, 0);
}

static unsigned int mipi_wait_dphy_stopstate(IMI_MIPI_T mipi_cfg)
{
	unsigned int val;
	unsigned int count = 0;
	unsigned int mask = STOPSTATE_CLK | ((1 << mipi_cfg->lanes) - 1);

	while (1) {
		val = csi2_read_reg(MIPI_PHY_STOPSTATE);
		if ((val & mask) == mask)
			return 0;

		udelay(200);
		count++;
		if (count >= 5) {
			log_e("wait_dphy_stopstate timeout, 0x%08x\n", val);
			return 1;
		}
	}
}

static unsigned int mipi_dphy_calib_check(IMI_MIPI_T mipi_cfg)
{
	unsigned int val;
	unsigned int done_flag, err_flag;

	/* Resistor calibration */
	done_flag = mipi_dphy_read(0x221) & 0x80;
	err_flag = mipi_dphy_read(0x222) & 0x1;
	if (!done_flag || err_flag) {
		log_e("Resistor calibration err\n");
		return 0xca000000;
	}
	log_i("Resistor calibration OK\n");

	/* Offset calibration */
	/*clklane*/
	val = mipi_dphy_read(0x39d);
	done_flag = val & 0x1;
	err_flag = ((val & 0x1E) != 0x10);
	if (!done_flag || !err_flag) {
		log_e("clklane calibration err\n");
		return 0xca010400;
	}

	/*datalane*/
	switch (mipi_cfg->lanes) {
		case 4:
			// Offset calibration
			val = mipi_dphy_read(0xb9f);
			done_flag = val & 0x02;
			err_flag = val & 0x04;
			if (!done_flag || err_flag) {
				log_e("datalane3 calibration err\n");
				return 0xca010300;
			}

			// DDL calibration
			val = mipi_dphy_read(0xbe0);
			done_flag = val & 0x04;
			if (!done_flag) {
				log_e("datalane3 DDL err\n");
				return 0xca020300;
			}

		case 3:
			// Offset calibration
			val = mipi_dphy_read(0x99f);
			done_flag = val & 0x02;
			err_flag = val & 0x04;
			if (!done_flag || err_flag) {
				log_e("datalane2 calibration err\n");
				return 0xca010200;
			}

			// DDL calibration
			val = mipi_dphy_read(0x9e0);
			done_flag = val & 0x04;
			if (!done_flag) {
				log_e("datalane2 DDL err\n");
				return 0xca020200;
			}
		case 2:
			// Offset calibration
			val = mipi_dphy_read(0x79f);
			done_flag = val & 0x02;
			err_flag = val & 0x04;
			if (!done_flag || err_flag) {
				log_e("datalane1 calibration err\n");
				return 0xca010100;
			}

			// DDL calibration
			val = mipi_dphy_read(0x7e0);
			done_flag = val & 0x04;
			if (!done_flag) {
				log_e("datalane1 DDL err\n");
				return 0xca020100;
			}
		case 1:
			// Offset calibration
			val = mipi_dphy_read(0x59f);
			done_flag = val & 0x02;
			err_flag = val & 0x04;
			if (!done_flag || err_flag) {
				log_e("datalane0 calibration err\n");
				return 0xca010000;
			}

			// DDL calibration
			val = mipi_dphy_read(0x5e0);
			done_flag = val & 0x04;
			if (!done_flag) {
				log_e("datalane0 DDL err\n");
				return 0xca020000;
			}
		default:
			break;
	}
	log_i("offset & DDL calibration OK\n");

	/* Skew calibration */
	if (mipi_cfg->mbps < 1500) {
		switch (mipi_cfg->lanes) {
			case 4:
				val = mipi_dphy_read(0xb2f);
				done_flag = val & 0x08;
				err_flag = val & 0x10;
				if (!done_flag || err_flag) {
					log_e("datalane3 Skew err\n");
					return 0xca030300;
				}
			case 3:
				val = mipi_dphy_read(0x92f);
				done_flag = val & 0x08;
				err_flag = val & 0x10;
				if (!done_flag || err_flag) {
					log_e("datalane2 Skew err\n");
					return 0xca030200;
				}
			case 2:
				val = mipi_dphy_read(0x72f);
				done_flag = val & 0x08;
				err_flag = val & 0x10;
				if (!done_flag || err_flag) {
					log_e("datalane1 Skew err\n");
					return 0xca030100;
				}
			case 1:
				val = mipi_dphy_read(0x52f);
				done_flag = val & 0x08;
				err_flag = val & 0x10;
				if (!done_flag || err_flag) {
					log_e("datalane0 Skew err\n");
					return 0xca030000;
				}
			default:
				break;
		}
	}
	log_i("Skew calibration OK\n");

	return 0;
}

#elif (VERISLC_DPHY_SIMULAT == 1)
static int mipi_dphy_write(u32 reg, u32 val)
{
	writel(val, g_mpcfg->mod_base+DPHY_OFFSET+reg);
	return 0;
}

static int mipi_dphy_read(u32 reg, u32 *ret_val)
{
	*ret_val = readl(g_mpcfg->mod_base+DPHY_OFFSET+reg);
	return *ret_val;
}

int start_simcam_stream(IMI_MIPI_T mipi_cfg, int tmout)
{
	unsigned int fm_in, fm_out;
	//unsigned int fm_int;
	unsigned int timeout = 0;

	switch (mipi_cfg->id) {
	case 1:
		writel(1, 0x08010064);
		break;
	case 0:
		writel(1, 0x08010060);
		break;
	default:
		log_e("ERR: Not Supported MIPI ID\n");
		return -1;
	};

	udelay(1000);

	imi_printf("Transfering ... \n");
	while (1) {
		fm_in = top_read_reg(TOP_IPI0_FRAME_COUNT_IN);
		fm_out = top_read_reg(TOP_IPI0_FRAME_COUNT_OUT);
		imi_printf("[%d] fm_in = 0x%x, fm_out = 0x%x\n", timeout, fm_in, fm_out);
		//fm_int = top_read_reg(TOP_IPI0_INT_STATUS);
		//if((fm_int&0x04) || (fm_out >= 2) || (fm_in >= 2)|| (timeout > 80) ) {
		if((fm_out >= 3) || (fm_in >= 3)|| (timeout > tmout) ) {
			if(timeout > tmout){
				log_e("Timeout, fm_in = 0x%x, fm_out = 0x%x\n", fm_in, fm_out);
			}
			udelay(500);
			imi_printf("Dumping image, fm_in = 0x%x, fm_out = 0x%x\n", fm_in, fm_out);
			switch(mipi_cfg->vcno) {
			case 3:
				memory_dump((void *)mipi_cfg->addr[2], (mipi_cfg->height)*(mipi_cfg->width)*2, 2);
			case 2:
				memory_dump((void *)mipi_cfg->addr[1], (mipi_cfg->height)*(mipi_cfg->width)*2, 1);
			case 1:
				memory_dump((void *)mipi_cfg->addr[0], (mipi_cfg->height)*(mipi_cfg->width)*2, 0);
				break;
			}
			break;
		}
		udelay(1000);
		timeout += 1;
	}
	return 0;
}

#endif

#if (SYNPSYS_DPHY_TESTCHIP != 1)
static void mipi_dphy_dump_regs(IMI_MIPI_T mipi_cfg)
{
	unsigned int val = 0;

	mipi_dphy_read(0x00, &val);
	imi_printf("DPHY reg 0x00: 0x%x\n", val);

	mipi_dphy_read(0x0C, &val);
	imi_printf("DPHY reg 0x0C: 0x%x\n", val);

	mipi_dphy_read(0x0D, &val);
	imi_printf("DPHY reg 0x0D: 0x%x\n", val);

	mipi_dphy_read(0xF0, &val);
	imi_printf("DPHY reg 0xF0: 0x%x\n", val);

	mipi_dphy_read(0xF1, &val);
	imi_printf("DPHY reg 0xF1: 0x%x\n", val);
}
#endif

static void mipi_dphy_assert(void)
{
	csi2_write_reg(MIPI_PHY_SHUTDOWNZ, 0);
	csi2_write_reg(MIPI_DPHY_RSTZ, 0);
	udelay(2);
}

static void mipi_dphy_deassert(void)
{
	udelay(2);
	csi2_write_reg(MIPI_PHY_SHUTDOWNZ, 1);
	udelay(2);
	csi2_write_reg(MIPI_DPHY_RSTZ, 1);
	udelay(2);
}

void mipi_dphy_init(IMI_MIPI_T mipi_cfg)
{

	imi_printf("Enter %s\n", __func__);
#if (SYNPSYS_DPHY_TESTCHIP == 1)
	// clear all control register bank
	clear_reg_bank();

	// set shutdownz & rstz to low
	top_choose_tester(RX_PHY_TESTER);

	// config hsfreqrange & cfgclkfreqrange
	top_choose_tester(GLUELOGIC_TESTER);
	mipi_dphy_write(0x04, 0x01);
	mipi_dphy_write(0x06, hsfreqrange & 0x7f);
	mipi_dphy_write(0x05, cfgclkfreqrange & 0xff);

	// config DDL target oscillation frequency
	top_choose_tester(RX_PHY_TESTER);
	mipi_dphy_osc_freq();
#endif

	// set shutdownz & rstz to high
	mipi_dphy_deassert();

#if (VERISLC_DPHY_TESTCHIP == 1)
	// mipi dphy i2c init
	if (mipi_cfg->id == 0) {
		mipi_i2c_dev = imi_i2c_init(I2C_0);
	} else if (mipi_cfg->id == 1) {
		mipi_i2c_dev = imi_i2c_init(I2C_2);
	}
	imi_printf("mipi i2c0 dev = 0x%x\n", (unsigned int)mipi_i2c_dev);

	// Enable DPHYRX register writable
	mipi_dphy_write(0x00, 0x01);
	// Config RX timing
	mipi_dphy_write(0x0C, 0x00);
	mipi_dphy_write(0x0D, 0x10);

	// Enable DPHY RX controls
	mipi_dphy_write(0xF0, 0x43);
	mipi_dphy_write(0xF1, 0x13);
	mipi_dphy_write(0xF0, 0x63);
#elif (VERISLC_DPHY_SIMULAT == 1)
	mipi_dphy_write(0x00, 0x01);
#endif

	imi_printf("Exit %s\n", __func__);
}

/***********************************************************************
 *
 * MIPI Interrupt Module
 *
 ***********************************************************************/

int gbl_ipi_int = 0;
irqreturn_t mipi_ipi_irq_handle(int irq, void* param)
{
	unsigned int reg_val_4C;
	unsigned int reg_val_50;
	unsigned int reg_val_54;

	log_d("=========== %s  Enter \n", __func__);
	reg_val_4C = top_read_reg(0x4C);
	reg_val_54 = top_read_reg(0x54);
	reg_val_50 = top_read_reg(0x50);
	log_d("            reg 0x4C (int enable):%x \n", reg_val_4C);
	log_d("            reg 0x54 (int status):%x (b)\n", reg_val_54);
	log_d("            reg 0x50 (int  clear):%x (b)\n", reg_val_50);

	top_write_reg(0x50, (reg_val_50 | (gbl_ipi_int)));

	reg_val_50 = top_read_reg(0x50);
	reg_val_54 = top_read_reg(0x54);
	log_d("            reg 0x50 (int  clear):%x (a)\n", reg_val_50);
	log_d("            reg 0x54 (int status):%x (a)\n", reg_val_54);
	log_d("            %s  Exit \n", __func__);
	return IRQ_HANDLED;
}

irqreturn_t mipi_ctl_irq_handle(int irq, void* param)
{
	log_d("=========== %s =========== \n", __func__);
	return IRQ_HANDLED;
}

void ipi_int_enable(int ipi_int)
{
	int val = 0;
	top_write_reg(0x4C, ipi_int);	//使能IPI所有中断
	val = top_read_reg(0x4C);
	log_d("== %s: IPI0 Int CTL(0x4C) = 0x%x \n", __func__, val);
}

void ipi_int_disable(int ipi_int)
{
	int val = 0;
	val = top_read_reg(0x4C);
	top_write_reg(0x4C, val&(~ipi_int));	//使能IPI所有中断
	val = top_read_reg(0x4C);
	log_d("== %s: IPI0 Int CTL(0x4C) = 0x%x \n", __func__, val);
}

void mipi_ctl_int_enable(void)
{
#if 0
	csi2_write_reg(MIPI_INT_MSK_PHY_FATAL, 0x0);
	csi2_write_reg(MIPI_INT_FORCE_PHY_FATAL, 0x0F);
	val = csi2_read_reg(mipi_cfg, MIPI_INT_ST_PHY_FATAL);
	log_d("MIPI_INT_ST_PHY_FATAL = 0x%x", val);
	
	csi2_write_reg(MIPI_INT_FORCE_PKT_FATAL, 0x0F);
	csi2_write_reg(MIPI_INT_MSK_PKT_FATAL, 0x0F);
	val = csi2_read_reg(mipi_cfg, MIPI_INT_ST_PKT_FATAL);
	log_d("MIPI_INT_ST_PKT_FATAL = 0x%x", val);
	csi2_write_reg(MIPI_INT_FORCE_FRAME_FATAL, 0x0F);
#endif
}



/***********************************************************************
 *
 * MIPI Module Func
 *
 ***********************************************************************/
static void mipi_rx_bus_enable(IMI_MIPI_T mipi_cfg)
{
	imi_printf("Enter %s\n", __func__);
	imi_printf("bus_base=0x%x\n", mipi_cfg->bus_base);
	writel(0xFF, mipi_cfg->bus_base + 0x04);
	writel(0x03, mipi_cfg->bus_base + 0x0c);
	writel(0x01, mipi_cfg->bus_base + 0x18);
	writel(0x00, mipi_cfg->bus_base + 0x00);
	imi_printf("Exit %s\n", __func__);
}

#if 1
static void mipi_clk_init(void)
{
	imi_printf("Enter %s\n", __func__);
#if (VERISLC_DPHY_SIMULAT == 1)
	//cfgclk, escclk, ipi0clk, ipi1clk, bus3clk
	clock_module_set((MClk_Base+0x100), 20,  Source_D);
	clock_module_set((MClk_Base+0x110), 20,  Source_D);
	clock_module_set((MClk_Base+0x150), 150, Source_V);
	clock_module_set((MClk_Base+0x160), 150, Source_V);
	clock_module_set((MClk_Base+0x40),  250, Source_V);
#endif
	imi_printf("Exit %s\n", __func__);
}
#else
#define MIPI_CLK_BASE 0x20F088C0
static void mipi_clk_init(void)
{
	//ipiclk, refclk, cfgclk, escclk
	//cfg clk
	writel(0x00, MIPI_CLK_BASE+0x100);
	writel(0x17, MIPI_CLK_BASE+0x104); // 20.5MB
	writel(0x00, MIPI_CLK_BASE+0x10C);
	imi_printf("Configure CFG_CLK to 20MB\n");

	//esc clk
	writel(0x00, MIPI_CLK_BASE+0x110);
	writel(0x17, MIPI_CLK_BASE+0x114); // 20.5MB
	writel(0x00, MIPI_CLK_BASE+0x11C);
	imi_printf("Configure ESC_CLK to 20MB\n");

	// ipi0 clk
	writel(0x03, MIPI_CLK_BASE+0x150);
	writel(0x07, MIPI_CLK_BASE+0x154);
	writel(0x00, MIPI_CLK_BASE+0x15C);
	imi_printf("Configure IPI0_CLK to 195MB\n");

	// ipi1 clk
	writel(0x03, MIPI_CLK_BASE+0x160);
	writel(0x07, MIPI_CLK_BASE+0x164);
	writel(0x00, MIPI_CLK_BASE+0x16C);
	imi_printf("Configure IPI0_CLK to 195MB\n");

	// bus3 clk
	writel(0x03, MIPI_CLK_BASE+0x40);
	writel(0x05, MIPI_CLK_BASE+0x44);
	writel(0x00, MIPI_CLK_BASE+0x4C);
	imi_printf("Configure IPI0_CLK to 195MB\n");

	
}
#endif

int mipi_base_config(IMI_MIPI_T mipi_cfg)
{
	imi_printf("Enter %s\n", __func__);
	if(mipi_cfg->id == 0) {
		mipi_cfg->mod_base = 0x24200000;
		mipi_cfg->bus_base = 0x24F00800;
	} else if(mipi_cfg->id == 1) {
		mipi_cfg->mod_base = 0x24300000;
		mipi_cfg->bus_base = 0x24F00C00;
	} else {
		log_e("ERR: Unsupported mipi id\n");
		return -1;
	}
#if (SYNPSYS_DPHY_TESTCHIP == 1)
	cfgclkfreqrange = (mipi_cfg->cfg_clk / 1000000 - 17) * 4;
	imi_csi_calc_freq(mipi_cfg->mbps);
	log_d("hsfreqrange:%d, osc_freq:%d, cfgclkfreqrange:%d\n",
		hsfreqrange, osc_freq, cfgclkfreqrange);
#endif

	imi_printf("mod_base=0x%x, bus_base=0x%x\n", mipi_cfg->mod_base, mipi_cfg->bus_base);
	mipi_rx_bus_enable(mipi_cfg);

	mipi_clk_init();
	mipi_dphy_assert();
	imi_printf("Exit %s\n", __func__);
	return 0;
}

int mipi_init(IMI_MIPI_T mipi_cfg)
{
	int ret = 0;
	g_mpcfg = mipi_cfg;

	imi_printf("===== MIPI init Enter =====\n");

	ret = mipi_base_config(mipi_cfg);
	if(ret) {
		log_e("ERR: mipi configure error\n");
	}

	camif_init(mipi_cfg);
	top_conf_init(mipi_cfg);

	mipi_ctl_init(mipi_cfg);
	top_enable_mipi();

	mipi_dphy_init(mipi_cfg);
#if (SYNPSYS_DPHY_TESTCHIP != 1)
	mipi_dphy_dump_regs(mipi_cfg);
#endif

#if (SYNPSYS_DPHY_TESTCHIP == 1)
	udelay(100);
	ret = mipi_wait_dphy_stopstate(mipi_cfg);
	if (!ret) {
		log_i("DPHY reset in LP state OK\n");
	}

	ret = mipi_dphy_calib_check(mipi_cfg);
	if (ret) {
		log_e("DPHY calib error\n");
	}
#endif
	imi_printf("====== MIPI init  OK ======\n");
	return ret;
}
#endif/*CHIP_IMI_1680*/
