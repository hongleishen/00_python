/*
 * I2C slave mode EEPROM simulator
 *
 * Copyright (C) 2014 by Wolfram Sang, Sang Engineering <wsa@sang-engineering.com>
 * Copyright (C) 2014 by Renesas Electronics Corporation
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the
 * Free Software Foundation; version 2 of the License.
 *
 * Because most IP blocks can only detect one I2C slave address anyhow, this
 * driver does not support simulating EEPROM types which take more than one
 * address. It is prepared to simulate bigger EEPROMs with an internal 16 bit
 * pointer, yet implementation is deferred until the need actually arises.
 */

#include <string.h>
#include "linux_compat.h"
#include "imi_io.h"
#include "i2c.h"
#include "stddef.h"
#include "elog.h"
#include "i2c_plat_slave.h"
#include "i2c-designware-core.h"

static inline void reg_add(struct i2c_client *client)
{
	struct eeprom_data *data = i2c_get_clientdata(client);
	//trans_buf(data->buffer, buf_trans(data->buffer, client->reg_len) +
	//		client->reg_len, client->reg_len);
	trans_buf(data->buffer, buf_trans(data->buffer, client->reg_len), client->reg_len);
	//imi_printf("	[%s]: data->buffer = 0x%x\n", __func__, data->buffer);
}

static u32 readbin(struct i2c_client *client)
{
	struct eeprom_data *data = i2c_get_clientdata(client);
	u8* buff = data->buffer;
	u32 reg = buf_trans(buff, client->reg_len);
	u32 val = readl(reg);
	//imi_printf("	[%s]: 0x%x=0x%x\n", __func__, reg, val);
	return val;
}

static void writebin(struct i2c_client *client)
{
	struct eeprom_data *eeprom = i2c_get_clientdata(client);
	u8* buff = eeprom->buffer;
	u32 reg = buf_trans(buff, client->reg_len);
	u32 val = buf_trans(buff + client->reg_len, client->regv_len);
	//imi_printf("	[%s]: 0x%x=0x%x\n", __func__, reg, val);
	writel(val, reg);
}

static int i2c_slave_cb(struct i2c_client *client,
				     enum i2c_slave_event event, u8 *val)
{
	struct eeprom_data *data = i2c_get_clientdata(client);

	//imi_printf("	event = 0x%x, val = 0x%x, data->buffer_idx = %d\n", 
				//event, *val, data->buffer_idx);

	switch (event) {
	case I2C_SLAVE_START_DET:
		if (data->buffer_idx) {
			log_e("START_DET err:0x%x\n", data->buffer_idx);
			return 1;
		}
		break;
	case I2C_SLAVE_WRITE_RECEIVED:
		//spin_lock(&data->buffer_lock);
		data->buffer[data->buffer_idx++] = *val;
		//imi_printf("	recv buff = 0x%x,%x,%x,%x; 0x%x, %x,%x,%x\n", 
			//data->buffer[0], data->buffer[1], data->buffer[2], data->buffer[3], 
			//data->buffer[4], data->buffer[5], data->buffer[6], data->buffer[7]);
	
		if (client->regv_len == data->buffer_idx - client->reg_len) {
			writebin(client);
		}
		//spin_unlock(&data->buffer_lock);
		break;

	case I2C_SLAVE_READ_PROCESSED:
		/* The previous byte made it to the bus, get next one */
		//data->buffer_idx++;
		break;

	case I2C_SLAVE_READ_REQUESTED:
		if (!data->send_idx) {
			data->send_idx = client->regv_len;
			data->val = readbin(client);
		}
		*val = (data->val >> (--data->send_idx << 3)) & 0xff;//get one byte
		//spin_unlock(&data->buffer_lock);
		break;

	case I2C_SLAVE_WRITE_REQUESTED:
	case I2C_SLAVE_STOP:
		data->buffer_idx = 0;
		break;

	default:
		break;
	}

	return 0;
}

struct i2c_client *i2c_slave_enable(struct dw_i2c_dev *i2c_controller)
{
	int ret;
	struct i2c_client *client = i2c_controller->slave;
	struct eeprom_data *data = client->priv;

	memset(data, 0x00, sizeof (*data));
	client->dev = (void *)i2c_controller;
	//spin_lock_init(&eeprom->buffer_lock);
	i2c_set_clientdata(client, data);
	
	ret = i2c_slave_register(client, i2c_slave_cb);
	if (ret) {
		log_e("*** %s slave register failed\n", __func__);
		return NULL;
	}

	return client;
};

int i2c_slave_eeprom_remove(struct i2c_client *client)
{
	i2c_slave_unregister(client);

	return 0;
}

